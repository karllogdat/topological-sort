{
  "nodes": [
    { "id": "[PF] Introduction to problem solving" },
    { "id": "[PF] A brief review of Von-Neumann architecture" },
    { "id": "[PF] Introduction to programming" },
    { "id": "[PF] Role of compiler and linker" },
    { "id": "[PF] Introduction to algorithms" },
    { "id": "[PF] Basic data types and variables" },
    { "id": "[PF] Input/output constructs" },
    { "id": "[PF] Arithmetic, comparison and logical operators" },
    { "id": "[PF] Conditional statements and execution flow for conditional statements" },
    { "id": "[PF] Repetitive statements and execution flow for repetitive statements" },
    { "id": "[PF] Lists and their memory organization" },
    { "id": "[PF] Multidimensional lists" },
    { "id": "[PF] Introduction to modular programming" },
    { "id": "[PF] Function definition and calling" },
    { "id": "[PF] Stack rolling and unrolling" },
    { "id": "[PF] String and string operations" },
    { "id": "[PF] Pointers/references" },
    { "id": "[PF] Static and dynamic memory allocation" },
    { "id": "[PF] File I/O operations" },
    { "id": "[DS] Mathematical reasoning" },
    { "id": "[DS] Propositional and predicate logic" },
    { "id": "[DS] Rules of inference" },
    { "id": "[DS] Proof by induction" },
    { "id": "[DS] Proof by contraposition" },
    { "id": "[DS] Proof by contradiction" },
    { "id": "[DS] Proof by implication" },
    { "id": "[DS] Set theory" },
    { "id": "[DS] Relations" },
    { "id": "[DS] Equivalence relations and partitions" },
    { "id": "[DS] Partial orderings" },
    { "id": "[DS] Functions and mappings" },
    { "id": "[DS] Function composition" },
    { "id": "[DS] Inverse functions" },
    { "id": "[DS] Recursive functions" },
    { "id": "[DS] Number Theory" },
    { "id": "[DS] Sequences and series" },
    { "id": "[DS] Counting" },
    { "id": "[DS] Inclusion and exclusion principle" },
    { "id": "[DS] Pigeonhole principle" },
    { "id": "[DS] Permutations and combinations" },
    { "id": "[DS] Algorithms" },
    { "id": "[DS] Searching and Sorting Algorithms" },
    { "id": "[DS] Elements of graph theory" },
    { "id": "[DS] Planar graphs" },
    { "id": "[DS] Graph coloring" },
    { "id": "[DS] Graph algorithms" },
    { "id": "[DS] Euler graph" },
    { "id": "[DS] Hamiltonian path" },
    { "id": "[DS] Rooted trees" },
    { "id": "[DS] Traversals" },
    { "id": "[DS] Recurrence relations" },
    { "id": "[OOP] Introduction to object oriented design" },
    { "id": "[OOP] History and advantages of object oriented design" },
    { "id": "[OOP] Introduction to object oriented programming concepts" },
    { "id": "[OOP] Classes" },
    { "id": "[OOP] Objects" },
    { "id": "[OOP] Data encapsulation" },
    { "id": "[OOP] Constructors" },
    { "id": "[OOP] Destructors" },
    { "id": "[OOP] Access modifiers" },
    { "id": "[OOP] Const vs non-const functions" },
    { "id": "[OOP] Static data members & functions" },
    { "id": "[OOP] Function overloading" },
    { "id": "[OOP] Operator overloading" },
    { "id": "[OOP] Identification of classes and their relationships" },
    { "id": "[OOP] Composition" },
    { "id": "[OOP] Aggregation" },
    { "id": "[OOP] Inheritance" },
    { "id": "[OOP] Multiple inheritance" },
    { "id": "[OOP] Polymorphism" },
    { "id": "[OOP] Abstract classes and interfaces" },
    { "id": "[OOP] Generic programming concepts" },
    { "id": "[OOP] Function & class templates" },
    { "id": "[OOP] Standard template library" },
    { "id": "[OOP] Object streams" },
    { "id": "[OOP] Data and object serialization using object streams" },
    { "id": "[OOP] Exception handling" },
    { "id": "[DBS] Basic database concepts" },
    { "id": "[DBS] Database approach vs. file-based system" },
    { "id": "[DBS] Database architecture, three-level schema architecture, data independence" },
    { "id": "[DBS] Relational data model: attributes, schemas, tuples, domains, relation instances, keys of relations, integrity constraints" },
    { "id": "[DBS] Relational algebra: selection, projection, Cartesian product, types of joins" },
    { "id": "[DBS] Structured Query Language (SQL): Joins and sub-queries in SQL, Grouping and aggregation in SQL" },
    { "id": "[DBS] Concurrency control, database backup and recovery" },
    { "id": "[DBS] Indexes" },
    { "id": "[DBS] Normalization, functional dependencies, normal forms" },
    { "id": "[DBS] Entity relationship model: entity sets, attributes, relationship, entity-relationship diagrams" },
    { "id": "[DBS] NoSQL systems" },
    { "id": "[DLD] Number Systems" },
    { "id": "[DLD] Logic Gates, Boolean Algebra" },
    { "id": "[DLD] Simplification Methods (K-Map, Quine-McCluskey method)" },
    { "id": "[DLD] Combination logic circuits and designs" },
    { "id": "[DLD] Binary Arithmetic and Arithmetic Circuits" },
    { "id": "[DLD] Flip Flops and Latches" },
    { "id": "[DLD] Asynchronous and Synchronous circuits" },
    { "id": "[DLD] Counters, Shift Registers, Triggered devices & its types" },
    { "id": "[DLD] Mealy machines and Moore machines" },
    { "id": "[DLD] Memory Elements, State Machines" },
    { "id": "[DLD] Introduction Programmable Logic Devices (CPLD, FPGA)" },
    { "id": "[DLD] Lab Assignments using tools such as Verilog HDL/VHDL, MultiSim" },
    { "id": "[DSA] Abstract data types, complexity analysis, Big Oh notation" },
    { "id": "[DSA] Stacks (linked lists and array implementations), Recursion and analyzing recursive algorithms, divide and conquer algorithms" },
    { "id": "[DSA] Sorting algorithms (selection, insertion, merge, quick, bubble, heap, shell, radix, bucket)" },
    { "id": "[DSA] Queue, dequeuer, priority queues (linked and array implementations of queues)" },
    { "id": "[DSA] Linked list & its various types, sorted linked list" },
    { "id": "[DSA] Searching an unsorted array, binary search for sorted arrays" },
    { "id": "[DSA] Hashing and indexing, open addressing and chaining" },
    { "id": "[DSA] Trees and tree traversals, binary search trees, heaps, M-way tress, balanced trees" },
    { "id": "[DSA] Graphs, breadth-first and depth-first traversal, topological order, shortest path, adjacency matrix and adjacency list implementations" },
    { "id": "[DSA] Memory management and garbage collection" },
    { "id": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies" },
    { "id": "[CN] Layered architecture, physical layer functionality, data link layer functionality" },
    { "id": "[CN] Multiple access techniques, circuit switching and packet switching" },
    { "id": "[CN] LAN technologies, wireless networks, MAC addressing, networking devices (both cn layered and cn access techniques)" },
    { "id": "[CN] Network layer protocols: IPv4 and IPv6, IP addressing, sub netting, CIDR, routing protocols" },
    { "id": "[CN] Transport layer protocols: ports and sockets, connection establishment, flow and congestion control" },
    { "id": "[CN] Application layer protocols" },
    { "id": "[CN] Latest trends in computer networks" },
    { "id": "[OS] Operating systems basics, system calls" },
    { "id": "[OS] Process concept and scheduling, inter-process communication" },
    { "id": "[OS] Multithreaded programming, multithreading models, threading issues" },
    { "id": "[OS] Process scheduling algorithms, thread scheduling, multiple-processor scheduling" },
    { "id": "[OS] Synchronization, critical section, synchronization hardware, synchronization problems, deadlocks, detecting and recovering from deadlocks" },
    { "id": "[OS] Memory management, swapping, contiguous memory allocation, segmentation & paging" },
    { "id": "[OS] Virtual memory management, demand paging, thrashing, memory-mapped files" },
    { "id": "[OS] File systems: file concept, directory and disk structure, directory implementation, free space management" },
    { "id": "[OS] Disk structure and scheduling, swap space management" },
    { "id": "[OS] System protection, virtual machines, operating system security" },
    { "id": "[AoA] Introduction; role of algorithms in computing" },
    { "id": "[AoA] Analysis on nature of input and size of input" },
    { "id": "[AoA] Asymptotic notations; Big-O, Big Ω, Big Θ, little-o, little-ω" },
    { "id": "[AoA] Sorting Algorithm analysis, loop invariants" },
    { "id": "[AoA] Recursion and recurrence relations" },
    { "id": "[AoA] Algorithm Design Techniques: Brute Force Approach, Divide-and-conquer approach (Merge, Quick Sort), Greedy approach" },
    { "id": "[AoA] Dynamic programming: Elements of Dynamic Programming" },
    { "id": "[AoA] Search trees; Heaps; Hashing" },
    { "id": "[AoA] Graph algorithms, shortest paths, sparse graphs" },
    { "id": "[AoA] String matching" },
    { "id": "[AoA] Introduction to complexity classes" }

  ],
  "links": [
    { 
      "source": "[PF] Introduction to problem solving", 
      "target": "[PF] A brief review of Von-Neumann architecture" },
    { 
      "source": "[PF] Introduction to problem solving", 
      "target": "[PF] Introduction to programming" },
    { 
      "source": "[PF] Introduction to programming", 
      "target": "[PF] Role of compiler and linker" },
    { 
      "source": "[PF] Introduction to programming", 
      "target": "[PF] Introduction to algorithms" },
    { 
      "source": "[PF] Introduction to programming", 
      "target": "[PF] Basic data types and variables" },
    { 
      "source": "[PF] Basic data types and variables", 
      "target": "[PF] Input/output constructs" },
    { 
      "source": "[PF] Basic data types and variables", 
      "target": "[PF] Arithmetic, comparison and logical operators" },
    { 
      "source": "[PF] Basic data types and variables", 
      "target": "[PF] Conditional statements and execution flow for conditional statements" },
    { 
      "source": "[PF] Basic data types and variables", 
      "target": "[PF] Repetitive statements and execution flow for repetitive statements" },
    { 
      "source": "[PF] Basic data types and variables", 
      "target": "[PF] Lists and their memory organization" },
    { 
      "source": "[PF] Lists and their memory organization", 
      "target": "[PF] Multidimensional lists" },
    { 
      "source": "[PF] Introduction to programming", 
      "target": "[PF] Introduction to modular programming" },
    { 
      "source": "[PF] Introduction to modular programming", 
      "target": "[PF] Function definition and calling" },
    { 
      "source": "[PF] Function definition and calling", 
      "target": "[PF] Stack rolling and unrolling" },
    { 
      "source": "[PF] Basic data types and variables", 
      "target": "[PF] String and string operations" },
    { 
      "source": "[PF] Basic data types and variables", 
      "target": "[PF] Pointers/references" },
    { 
      "source": "[PF] Basic data types and variables", 
      "target": "[PF] Static and dynamic memory allocation" },
    { 
      "source": "[PF] Basic data types and variables", 
      "target": "[PF] File I/O operations" },
    { 
      "source": "[DS] Mathematical reasoning", 
      "target": "[DS] Propositional and predicate logic" },
    { 
      "source": "[DS] Propositional and predicate logic", 
      "target": "[DS] Rules of inference" },
    { 
      "source": "[DS] Rules of inference", 
      "target": "[DS] Proof by induction" },
    { 
      "source": "[DS] Rules of inference", 
      "target": "[DS] Proof by contraposition" },
    { 
      "source": "[DS] Rules of inference", 
      "target": "[DS] Proof by contradiction" },
    { 
      "source": "[DS] Rules of inference", 
      "target": "[DS] Proof by implication" },
    { 
      "source": "[DS] Mathematical reasoning", 
      "target": "[DS] Set theory" },
    { 
      "source": "[DS] Set theory", 
      "target": "[DS] Relations" },
    { 
      "source": "[DS] Relations", 
      "target": "[DS] Equivalence relations and partitions" },
    { 
      "source": "[DS] Relations", 
      "target": "[DS] Partial orderings" },
    { 
      "source": "[DS] Set theory", 
      "target": "[DS] Functions and mappings" },
    { 
      "source": "[DS] Functions and mappings", 
      "target": "[DS] Function composition" },
    { 
      "source": "[DS] Functions and mappings", 
      "target": "[DS] Inverse functions" },
    { 
      "source": "[DS] Functions and mappings", 
      "target": "[DS] Recursive functions" },
    { 
      "source": "[DS] Mathematical reasoning", 
      "target": "[DS] Number Theory" },
    { 
      "source": "[DS] Mathematical reasoning", 
      "target": "[DS] Sequences and series" },
    { 
      "source": "[DS] Mathematical reasoning", 
      "target": "[DS] Counting" },
    { 
      "source": "[DS] Counting", 
      "target": "[DS] Inclusion and exclusion principle" },
    { 
      "source": "[DS] Counting", 
      "target": "[DS] Pigeonhole principle" },
    { 
      "source": "[DS] Counting", 
      "target": "[DS] Permutations and combinations" },
    { 
      "source": "[DS] Mathematical reasoning", 
      "target": "[DS] Algorithms" },
    { 
      "source": "[DS] Algorithms", 
      "target": "[DS] Searching and Sorting Algorithms" },
    { 
      "source": "[DS] Mathematical reasoning", 
      "target": "[DS] Elements of graph theory" },
    { 
      "source": "[DS] Elements of graph theory", 
      "target": "[DS] Planar graphs" },
    { 
      "source": "[DS] Elements of graph theory", 
      "target": "[DS] Graph coloring" },
    { 
      "source": "[DS] Elements of graph theory", 
      "target": "[DS] Graph algorithms" },
    { 
      "source": "[DS] Elements of graph theory", 
      "target": "[DS] Euler graph" },
    { 
      "source": "[DS] Elements of graph theory", 
      "target": "[DS] Hamiltonian path" },
    { 
      "source": "[DS] Elements of graph theory", 
      "target": "[DS] Rooted trees" },
    { 
      "source": "[DS] Rooted trees", 
      "target": "[DS] Traversals" },
    { 
      "source": "[DS] Mathematical reasoning", 
      "target": "[DS] Recurrence relations" },
    { 
      "source": "[OOP] Introduction to object oriented design", 
      "target": "[OOP] History and advantages of object oriented design" },
    { 
      "source": "[OOP] Introduction to object oriented design", 
      "target": "[OOP] Introduction to object oriented programming concepts" },
    { 
      "source": "[OOP] Introduction to object oriented programming concepts", 
      "target": "[OOP] Classes" },
    { 
      "source": "[OOP] Classes", 
      "target": "[OOP] Objects" },
    { 
      "source": "[OOP] Classes", 
      "target": "[OOP] Data encapsulation" },
    { 
      "source": "[OOP] Classes", 
      "target": "[OOP] Access modifiers" },
    { 
      "source": "[OOP] Classes", 
      "target": "[OOP] Const vs non-const functions" },
    { 
      "source": "[OOP] Classes", 
      "target": "[OOP] Static data members & functions" },
    { 
      "source": "[OOP] Classes", 
      "target": "[OOP] Constructors" },
    { 
      "source": "[OOP] Classes", 
      "target": "[OOP] Destructors" },
    { 
      "source": "[OOP] Classes", 
      "target": "[OOP] Function overloading" },
    { 
      "source": "[OOP] Classes", 
      "target": "[OOP] Operator overloading" },
    { 
      "source": "[OOP] Classes", 
      "target": "[OOP] Identification of classes and their relationships" },
    { 
      "source": "[OOP] Identification of classes and their relationships", 
      "target": "[OOP] Composition" },
    { 
      "source": "[OOP] Identification of classes and their relationships", 
      "target": "[OOP] Aggregation" },
    { 
      "source": "[OOP] Identification of classes and their relationships", 
      "target": "[OOP] Inheritance" },
    { 
      "source": "[OOP] Inheritance", 
      "target": "[OOP] Multiple inheritance" },
    { 
      "source": "[OOP] Inheritance", 
      "target": "[OOP] Polymorphism" },
    { 
      "source": "[OOP] Polymorphism", 
      "target": "[OOP] Abstract classes and interfaces" },
    { 
      "source": "[OOP] Introduction to object oriented programming concepts", 
      "target": "[OOP] Generic programming concepts" },
    { 
      "source": "[OOP] Generic programming concepts", 
      "target": "[OOP] Function & class templates" },
    { 
      "source": "[OOP] Function & class templates", 
      "target": "[OOP] Standard template library" },
    { 
      "source": "[OOP] Classes", 
      "target": "[OOP] Object streams" },
    { 
      "source": "[OOP] Object streams", 
      "target": "[OOP] Data and object serialization using object streams" },
    { 
      "source": "[OOP] Introduction to object oriented programming concepts", 
      "target": "[OOP] Exception handling" },
    {
      "source": "[DBS] Basic database concepts",
      "target": "[DBS] Database approach vs. file-based system"
    },
    {
      "source": "[DBS] Basic database concepts",
      "target": "[DBS] Database architecture, three-level schema architecture, data independence"
    },
    {
      "source": "[DBS] Database architecture, three-level schema architecture, data independence",
      "target": "[DBS] Relational data model: attributes, schemas, tuples, domains, relation instances, keys of relations, integrity constraints"
    },
    {
      "source": "[DBS] Relational data model: attributes, schemas, tuples, domains, relation instances, keys of relations, integrity constraints",
      "target": "[DBS] Relational algebra: selection, projection, Cartesian product, types of joins"
    },
    {
      "source": "[DBS] Relational data model: attributes, schemas, tuples, domains, relation instances, keys of relations, integrity constraints",
      "target": "[DBS] Normalization, functional dependencies, normal forms"
    },
    {
      "source": "[DBS] Basic database concepts",
      "target": "[DBS] Entity relationship model: entity sets, attributes, relationship, entity-relationship diagrams"
    },
    {
      "source": "[DBS] Relational algebra: selection, projection, Cartesian product, types of joins",
      "target": "[DBS] Structured Query Language (SQL): Joins and sub-queries in SQL, Grouping and aggregation in SQL"
    },
    {
      "source": "[DBS] Normalization, functional dependencies, normal forms",
      "target": "[DBS] Structured Query Language (SQL): Joins and sub-queries in SQL, Grouping and aggregation in SQL"
    },
    {
      "source": "[DBS] Structured Query Language (SQL): Joins and sub-queries in SQL, Grouping and aggregation in SQL",
      "target": "[DBS] Concurrency control, database backup and recovery"
    },
    {
      "source": "[DBS] Structured Query Language (SQL): Joins and sub-queries in SQL, Grouping and aggregation in SQL",
      "target": "[DBS] Indexes"
    },
    {
      "source": "[DBS] Basic database concepts",
      "target": "[DBS] NoSQL systems"
    },
    {
      "source": "[DLD] Number Systems",
      "target": "[DLD] Logic Gates, Boolean Algebra"
    },
    {
      "source": "[DLD] Logic Gates, Boolean Algebra",
      "target": "[DLD] Simplification Methods (K-Map, Quine-McCluskey method)"
    },
    {
      "source": "[DLD] Simplification Methods (K-Map, Quine-McCluskey method)",
      "target": "[DLD] Combination logic circuits and designs"
    },
    {
      "source": "[DLD] Number Systems",
      "target": "[DLD] Binary Arithmetic and Arithmetic Circuits"
    },
    {
      "source": "[DLD] Combination logic circuits and designs",
      "target": "[DLD] Flip Flops and Latches"
    },
    {
      "source": "[DLD] Flip Flops and Latches",
      "target": "[DLD] Asynchronous and Synchronous circuits"
    },
    {
      "source": "[DLD] Asynchronous and Synchronous circuits",
      "target": "[DLD] Counters, Shift Registers, Triggered devices & its types"
    },
    {
      "source": "[DLD] Counters, Shift Registers, Triggered devices & its types",
      "target": "[DLD] Mealy machines and Moore machines"
    },
    {
      "source": "[DLD] Mealy machines and Moore machines",
      "target": "[DLD] Memory Elements, State Machines"
    },
    {
      "source": "[DLD] Memory Elements, State Machines",
      "target": "[DLD] Introduction Programmable Logic Devices (CPLD, FPGA)"
    },
    {
      "source": "[DLD] Introduction Programmable Logic Devices (CPLD, FPGA)",
      "target": "[DLD] Lab Assignments using tools such as Verilog HDL/VHDL, MultiSim"
    },
    {
      "source": "[DSA] Abstract data types, complexity analysis, Big Oh notation",
      "target": "[DSA] Stacks (linked lists and array implementations), Recursion and analyzing recursive algorithms, divide and conquer algorithms"
    },
    {
      "source": "[DSA] Stacks (linked lists and array implementations), Recursion and analyzing recursive algorithms, divide and conquer algorithms",
      "target": "[DSA] Sorting algorithms (selection, insertion, merge, quick, bubble, heap, shell, radix, bucket)"
    },
    {
      "source": "[DSA] Abstract data types, complexity analysis, Big Oh notation",
      "target": "[DSA] Queue, dequeuer, priority queues (linked and array implementations of queues)"
    },
    {
      "source": "[DSA] Abstract data types, complexity analysis, Big Oh notation",
      "target": "[DSA] Linked list & its various types, sorted linked list"
    },
    {
      "source": "[DSA] Abstract data types, complexity analysis, Big Oh notation",
      "target": "[DSA] Searching an unsorted array, binary search for sorted arrays"
    },
    {
      "source": "[DSA] Abstract data types, complexity analysis, Big Oh notation",
      "target": "[DSA] Hashing and indexing, open addressing and chaining"
    },
    {
      "source": "[DSA] Abstract data types, complexity analysis, Big Oh notation",
      "target": "[DSA] Trees and tree traversals, binary search trees, heaps, M-way tress, balanced trees"
    },
    {
      "source": "[DSA] Abstract data types, complexity analysis, Big Oh notation",
      "target": "[DSA] Graphs, breadth-first and depth-first traversal, topological order, shortest path, adjacency matrix and adjacency list implementations"
    },
    {
      "source": "[DSA] Abstract data types, complexity analysis, Big Oh notation",
      "target": "[DSA] Memory management and garbage collection"
    },
    {
      "source": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies",
      "target": "[CN] Layered architecture, physical layer functionality, data link layer functionality"
    },
    {
      "source": "[CN] Layered architecture, physical layer functionality, data link layer functionality",
      "target": "[CN] Multiple access techniques, circuit switching and packet switching"
    },
    {
      "source": "[CN] Multiple access techniques, circuit switching and packet switching",
      "target": "[CN] LAN technologies, wireless networks, MAC addressing, networking devices (both cn layered and cn access techniques)"
    },
    {
      "source": "[CN] Layered architecture, physical layer functionality, data link layer functionality",
      "target": "[CN] LAN technologies, wireless networks, MAC addressing, networking devices (both cn layered and cn access techniques)"
    },
    {
      "source": "[CN] LAN technologies, wireless networks, MAC addressing, networking devices (both cn layered and cn access techniques)",
      "target": "[CN] Network layer protocols: IPv4 and IPv6, IP addressing, sub netting, CIDR, routing protocols"
    },
    {
      "source": "[CN] Network layer protocols: IPv4 and IPv6, IP addressing, sub netting, CIDR, routing protocols",
      "target": "[CN] Transport layer protocols: ports and sockets, connection establishment, flow and congestion control"
    },
    {
      "source": "[CN] Transport layer protocols: ports and sockets, connection establishment, flow and congestion control",
      "target": "[CN] Application layer protocols"
    },
    {
      "source": "[CN] Application layer protocols",
      "target": "[CN] Latest trends in computer networks"
    },
    {
      "source": "[OS] Operating systems basics, system calls",
      "target": "[OS] Process concept and scheduling, inter-process communication"
    },
    {
      "source": "[OS] Process concept and scheduling, inter-process communication",
      "target": "[OS] Multithreaded programming, multithreading models, threading issues"
    },
    {
      "source": "[OS] Multithreaded programming, multithreading models, threading issues",
      "target": "[OS] Process scheduling algorithms, thread scheduling, multiple-processor scheduling"
    },
    {
      "source": "[OS] Process scheduling algorithms, thread scheduling, multiple-processor scheduling",
      "target": "[OS] Synchronization, critical section, synchronization hardware, synchronization problems, deadlocks, detecting and recovering from deadlocks"
    },
    {
      "source": "[OS] Synchronization, critical section, synchronization hardware, synchronization problems, deadlocks, detecting and recovering from deadlocks",
      "target": "[OS] Memory management, swapping, contiguous memory allocation, segmentation & paging"
    },
    {
      "source": "[OS] Memory management, swapping, contiguous memory allocation, segmentation & paging",
      "target": "[OS] Virtual memory management, demand paging, thrashing, memory-mapped files"
    },
    {
      "source": "[OS] Virtual memory management, demand paging, thrashing, memory-mapped files",
      "target": "[OS] File systems: file concept, directory and disk structure, directory implementation, free space management"
    },
    {
      "source": "[OS] File systems: file concept, directory and disk structure, directory implementation, free space management",
      "target": "[OS] Disk structure and scheduling, swap space management"
    },
    {
      "source": "[OS] Disk structure and scheduling, swap space management",
      "target": "[OS] System protection, virtual machines, operating system security"
    },
    {
      "source": "[AoA] Introduction; role of algorithms in computing",
      "target": "[AoA] Analysis on nature of input and size of input"
    },
    {
      "source": "[AoA] Analysis on nature of input and size of input",
      "target": "[AoA] Asymptotic notations; Big-O, Big Ω, Big Θ, little-o, little-ω"
    },
    {
      "source": "[AoA] Asymptotic notations; Big-O, Big Ω, Big Θ, little-o, little-ω",
      "target": "[AoA] Sorting Algorithm analysis, loop invariants"
    },
    {
      "source": "[AoA] Asymptotic notations; Big-O, Big Ω, Big Θ, little-o, little-ω",
      "target": "[AoA] Recursion and recurrence relations"
    },
    {
      "source": "[AoA] Recursion and recurrence relations",
      "target": "[AoA] Algorithm Design Techniques: Brute Force Approach, Divide-and-conquer approach (Merge, Quick Sort), Greedy approach"
    },
    {
      "source": "[AoA] Algorithm Design Techniques: Brute Force Approach, Divide-and-conquer approach (Merge, Quick Sort), Greedy approach",
      "target": "[AoA] Dynamic programming: Elements of Dynamic Programming"
    },
    {
      "source": "[AoA] Algorithm Design Techniques: Brute Force Approach, Divide-and-conquer approach (Merge, Quick Sort), Greedy approach",
      "target": "[AoA] Search trees; Heaps; Hashing"
    },
    {
      "source": "[AoA] Algorithm Design Techniques: Brute Force Approach, Divide-and-conquer approach (Merge, Quick Sort), Greedy approach",
      "target": "[AoA] Graph algorithms, shortest paths, sparse graphs"
    },
    {
      "source": "[AoA] Dynamic programming: Elements of Dynamic Programming",
      "target": "[AoA] Graph algorithms, shortest paths, sparse graphs"
    },
    {
      "source": "[AoA] Graph algorithms, shortest paths, sparse graphs",
      "target": "[AoA] String matching"
    },
    {
      "source": "[AoA] Algorithm Design Techniques: Brute Force Approach, Divide-and-conquer approach (Merge, Quick Sort), Greedy approach",
      "target": "[AoA] Introduction to complexity classes"
    },

    { "source": "[DS] Proof by induction", "target": "[PF] Introduction to problem solving" },
    { "source": "[DS] Proof by contraposition", "target": "[PF] Introduction to problem solving" },
    { "source": "[DS] Proof by contradiction", "target": "[PF] Introduction to problem solving" },
    { "source": "[DS] Proof by implication", "target": "[PF] Introduction to problem solving" },
    { "source": "[DS] Equivalence relations and partitions", "target": "[PF] Introduction to problem solving" },
    { "source": "[DS] Partial orderings", "target": "[PF] Introduction to problem solving" },
    { "source": "[DS] Function composition", "target": "[PF] Introduction to problem solving" },
    { "source": "[DS] Inverse functions", "target": "[PF] Introduction to problem solving" },
    { "source": "[DS] Recursive functions", "target": "[PF] Introduction to problem solving" },
    { "source": "[DS] Number Theory", "target": "[PF] Introduction to problem solving" },
    { "source": "[DS] Sequences and series", "target": "[PF] Introduction to problem solving" },
    { "source": "[DS] Inclusion and exclusion principle", "target": "[PF] Introduction to problem solving" },
    { "source": "[DS] Pigeonhole principle", "target": "[PF] Introduction to problem solving" },
    { "source": "[DS] Permutations and combinations", "target": "[PF] Introduction to problem solving" },
    { "source": "[DS] Searching and Sorting Algorithms", "target": "[PF] Introduction to problem solving" },
    { "source": "[DS] Planar graphs", "target": "[PF] Introduction to problem solving" },
    { "source": "[DS] Graph coloring", "target": "[PF] Introduction to problem solving" },
    { "source": "[DS] Graph algorithms", "target": "[PF] Introduction to problem solving" },
    { "source": "[DS] Euler graph", "target": "[PF] Introduction to problem solving" },
    { "source": "[DS] Hamiltonian path", "target": "[PF] Introduction to problem solving" },
    { "source": "[DS] Traversals", "target": "[PF] Introduction to problem solving" },
    { "source": "[DS] Recurrence relations", "target": "[PF] Introduction to problem solving" },

    { "source": "[PF] A brief review of Von-Neumann architecture", "target": "[OOP] Introduction to object oriented design" },
    { "source": "[PF] Role of compiler and linker", "target": "[OOP] Introduction to object oriented design" },
    { "source": "[PF] Introduction to algorithms", "target": "[OOP] Introduction to object oriented design" },
    { "source": "[PF] Input/output constructs", "target": "[OOP] Introduction to object oriented design" },
    { "source": "[PF] Arithmetic, comparison and logical operators", "target": "[OOP] Introduction to object oriented design" },
    { "source": "[PF] Conditional statements and execution flow for conditional statements", "target": "[OOP] Introduction to object oriented design" },
    { "source": "[PF] Repetitive statements and execution flow for repetitive statements", "target": "[OOP] Introduction to object oriented design" },
    { "source": "[PF] Multidimensional lists", "target": "[OOP] Introduction to object oriented design" },
    { "source": "[PF] Stack rolling and unrolling", "target": "[OOP] Introduction to object oriented design" },
    { "source": "[PF] String and string operations", "target": "[OOP] Introduction to object oriented design" },
    { "source": "[PF] Pointers/references", "target": "[OOP] Introduction to object oriented design" },
    { "source": "[PF] Static and dynamic memory allocation", "target": "[OOP] Introduction to object oriented design" },
    { "source": "[PF] File I/O operations", "target": "[OOP] Introduction to object oriented design" },

    { "source": "[DS] Proof by induction", "target": "[DBS] Basic database concepts" },
    { "source": "[DS] Proof by contraposition", "target": "[DBS] Basic database concepts" },
    { "source": "[DS] Proof by contradiction", "target": "[DBS] Basic database concepts" },
    { "source": "[DS] Proof by implication", "target": "[DBS] Basic database concepts" },
    { "source": "[DS] Equivalence relations and partitions", "target": "[DBS] Basic database concepts" },
    { "source": "[DS] Partial orderings", "target": "[DBS] Basic database concepts" },
    { "source": "[DS] Function composition", "target": "[DBS] Basic database concepts" },
    { "source": "[DS] Inverse functions", "target": "[DBS] Basic database concepts" },
    { "source": "[DS] Recursive functions", "target": "[DBS] Basic database concepts" },
    { "source": "[DS] Number Theory", "target": "[DBS] Basic database concepts" },
    { "source": "[DS] Sequences and series", "target": "[DBS] Basic database concepts" },
    { "source": "[DS] Inclusion and exclusion principle", "target": "[DBS] Basic database concepts" },
    { "source": "[DS] Pigeonhole principle", "target": "[DBS] Basic database concepts" },
    { "source": "[DS] Permutations and combinations", "target": "[DBS] Basic database concepts" },
    { "source": "[DS] Searching and Sorting Algorithms", "target": "[DBS] Basic database concepts" },
    { "source": "[DS] Planar graphs", "target": "[DBS] Basic database concepts" },
    { "source": "[DS] Graph coloring", "target": "[DBS] Basic database concepts" },
    { "source": "[DS] Graph algorithms", "target": "[DBS] Basic database concepts" },
    { "source": "[DS] Euler graph", "target": "[DBS] Basic database concepts" },
    { "source": "[DS] Hamiltonian path", "target": "[DBS] Basic database concepts" },
    { "source": "[DS] Traversals", "target": "[DBS] Basic database concepts" },
    { "source": "[DS] Recurrence relations", "target": "[DBS] Basic database concepts" },

    { "source": "[DS] Proof by induction", "target": "[DLD] Number Systems" },
    { "source": "[DS] Proof by contraposition", "target": "[DLD] Number Systems" },
    { "source": "[DS] Proof by contradiction", "target": "[DLD] Number Systems" },
    { "source": "[DS] Proof by implication", "target": "[DLD] Number Systems" },
    { "source": "[DS] Equivalence relations and partitions", "target": "[DLD] Number Systems" },
    { "source": "[DS] Partial orderings", "target": "[DLD] Number Systems" },
    { "source": "[DS] Function composition", "target": "[DLD] Number Systems" },
    { "source": "[DS] Inverse functions", "target": "[DLD] Number Systems" },
    { "source": "[DS] Recursive functions", "target": "[DLD] Number Systems" },
    { "source": "[DS] Number Theory", "target": "[DLD] Number Systems" },
    { "source": "[DS] Sequences and series", "target": "[DLD] Number Systems" },
    { "source": "[DS] Inclusion and exclusion principle", "target": "[DLD] Number Systems" },
    { "source": "[DS] Pigeonhole principle", "target": "[DLD] Number Systems" },
    { "source": "[DS] Permutations and combinations", "target": "[DLD] Number Systems" },
    { "source": "[DS] Searching and Sorting Algorithms", "target": "[DLD] Number Systems" },
    { "source": "[DS] Planar graphs", "target": "[DLD] Number Systems" },
    { "source": "[DS] Graph coloring", "target": "[DLD] Number Systems" },
    { "source": "[DS] Graph algorithms", "target": "[DLD] Number Systems" },
    { "source": "[DS] Euler graph", "target": "[DLD] Number Systems" },
    { "source": "[DS] Hamiltonian path", "target": "[DLD] Number Systems" },
    { "source": "[DS] Traversals", "target": "[DLD] Number Systems" },
    { "source": "[DS] Recurrence relations", "target": "[DLD] Number Systems" },

    { "source": "[PF] A brief review of Von-Neumann architecture", "target": "[DSA] Abstract data types, complexity analysis, Big Oh notation" },
    { "source": "[PF] Role of compiler and linker", "target": "[DSA] Abstract data types, complexity analysis, Big Oh notation" },
    { "source": "[PF] Introduction to algorithms", "target": "[DSA] Abstract data types, complexity analysis, Big Oh notation" },
    { "source": "[PF] Input/output constructs", "target": "[DSA] Abstract data types, complexity analysis, Big Oh notation" },
    { "source": "[PF] Arithmetic, comparison and logical operators", "target": "[DSA] Abstract data types, complexity analysis, Big Oh notation" },
    { "source": "[PF] Conditional statements and execution flow for conditional statements", "target": "[DSA] Abstract data types, complexity analysis, Big Oh notation" },
    { "source": "[PF] Repetitive statements and execution flow for repetitive statements", "target": "[DSA] Abstract data types, complexity analysis, Big Oh notation" },
    { "source": "[PF] Multidimensional lists", "target": "[DSA] Abstract data types, complexity analysis, Big Oh notation" },
    { "source": "[PF] Stack rolling and unrolling", "target": "[DSA] Abstract data types, complexity analysis, Big Oh notation" },
    { "source": "[PF] String and string operations", "target": "[DSA] Abstract data types, complexity analysis, Big Oh notation" },
    { "source": "[PF] Pointers/references", "target": "[DSA] Abstract data types, complexity analysis, Big Oh notation" },
    { "source": "[PF] Static and dynamic memory allocation", "target": "[DSA] Abstract data types, complexity analysis, Big Oh notation" },
    { "source": "[PF] File I/O operations", "target": "[DSA] Abstract data types, complexity analysis, Big Oh notation" },

    { "source": "[DS] Proof by induction", "target": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies" },
    { "source": "[DS] Proof by contraposition", "target": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies" },
    { "source": "[DS] Proof by contradiction", "target": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies" },
    { "source": "[DS] Proof by implication", "target": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies" },
    { "source": "[DS] Equivalence relations and partitions", "target": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies" },
    { "source": "[DS] Partial orderings", "target": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies" },
    { "source": "[DS] Function composition", "target": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies" },
    { "source": "[DS] Inverse functions", "target": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies" },
    { "source": "[DS] Recursive functions", "target": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies" },
    { "source": "[DS] Number Theory", "target": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies" },
    { "source": "[DS] Sequences and series", "target": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies" },
    { "source": "[DS] Inclusion and exclusion principle", "target": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies" },
    { "source": "[DS] Pigeonhole principle", "target": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies" },
    { "source": "[DS] Permutations and combinations", "target": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies" },
    { "source": "[DS] Searching and Sorting Algorithms", "target": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies" },
    { "source": "[DS] Planar graphs", "target": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies" },
    { "source": "[DS] Graph coloring", "target": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies" },
    { "source": "[DS] Graph algorithms", "target": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies" },
    { "source": "[DS] Euler graph", "target": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies" },
    { "source": "[DS] Hamiltonian path", "target": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies" },
    { "source": "[DS] Traversals", "target": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies" },
    { "source": "[DS] Recurrence relations", "target": "[CN] Introduction and protocols architecture, basic concepts of networking, network topologies" },

    { "source": "[DSA] Sorting algorithms (selection, insertion, merge, quick, bubble, heap, shell, radix, bucket)", "target": "[OS] Operating systems basics, system calls" },
    { "source": "[DSA] Queue, dequeuer, priority queues (linked and array implementations of queues)", "target": "[OS] Operating systems basics, system calls" },
    { "source": "[DSA] Linked list & its various types, sorted linked list", "target": "[OS] Operating systems basics, system calls" },
    { "source": "[DSA] Searching an unsorted array, binary search for sorted arrays", "target": "[OS] Operating systems basics, system calls" },
    { "source": "[DSA] Hashing and indexing, open addressing and chaining", "target": "[OS] Operating systems basics, system calls" },
    { "source": "[DSA] Trees and tree traversals, binary search trees, heaps, M-way tress, balanced trees", "target": "[OS] Operating systems basics, system calls" },
    { "source": "[DSA] Graphs, breadth-first and depth-first traversal, topological order, shortest path, adjacency matrix and adjacency list implementations", "target": "[OS] Operating systems basics, system calls" },
    { "source": "[DSA] Memory management and garbage collection", "target": "[OS] Operating systems basics, system calls" },

    { "source": "[DSA] Sorting algorithms (selection, insertion, merge, quick, bubble, heap, shell, radix, bucket)", "target": "[AoA] Introduction; role of algorithms in computing" },
    { "source": "[DSA] Queue, dequeuer, priority queues (linked and array implementations of queues)", "target": "[AoA] Introduction; role of algorithms in computing" },
    { "source": "[DSA] Linked list & its various types, sorted linked list", "target": "[AoA] Introduction; role of algorithms in computing" },
    { "source": "[DSA] Searching an unsorted array, binary search for sorted arrays", "target": "[AoA] Introduction; role of algorithms in computing" },
    { "source": "[DSA] Hashing and indexing, open addressing and chaining", "target": "[AoA] Introduction; role of algorithms in computing" },
    { "source": "[DSA] Trees and tree traversals, binary search trees, heaps, M-way tress, balanced trees", "target": "[AoA] Introduction; role of algorithms in computing" },
    { "source": "[DSA] Graphs, breadth-first and depth-first traversal, topological order, shortest path, adjacency matrix and adjacency list implementations", "target": "[AoA] Introduction; role of algorithms in computing" },
    { "source": "[DSA] Memory management and garbage collection", "target": "[AoA] Introduction; role of algorithms in computing" }

  ]
}